#!/usr/bin/env python2
"""Diver utilities to handle logging

This module can be used across all DSP tools to use a homogeneous logging structure.
It also add a logging buffer that can be used within Matlab to redirect the logging.

Examples:
    Example how to use the LogBuffer to stream, through a buffer, the whole ``dsp_tools``
    package logging.

    >>> from dsp_tools import log
    >>> log.setup()  # this load default configuration with no logging enabled
    >>> logger = log.get_logger('dsp_tools')
    >>> formatter = log.get_formatter('matlab')
    >>> log_buffer = log.LogBuffer(logger, 'DEBUG', formatter)  # this will enable logging

Notes:
    the logging structure (loggers, handlers and formatters) are defined within the
    configuration file ``./config/logging.json``. You can get the file with
    ``dsp_tools.util.get_config('logging')``.

Todo:
    * extend unittest to cover all methods

Warnings:
    The level of a logger will propagate to it's handlers. Avoid setting a level
    for root (different of ``NOTSET``). Preferably set levels within handlers direclty.

References:
    * https://docs.python.org/2/library/logging.html
"""

import sys
import json
import logging
import logging.config
import weakref

from StringIO import StringIO

from . import util


###############################################################################
class LoggerManager(object):

    """Summary

    Attributes:
        level (TYPE): Description
        log (TYPE): Description
        mode (TYPE): Description

    Deleted Attributes:
        loggger (TYPE): Description
    """

    def __init__(self, mode=None, level=None, logger=None):
        """Setup logging configuration
        call this method to enable logging using the pre-defined structure

        Args:
            mode (str, optional): logging type, can be ``all``, ``debug``, ``console``,
                ``files`` or empty. (default is empty which will not enable any logging)
            level (str/int, optional): logging level for console (default INFO)
            logger (None, optional): Description
        """
        # logger
        self.log = logger or logging.getLogger(__name__ + '.' + self.__class__.__name__)
        # set default
        self.mode = mode
        self.level = level or logging.NOTSET

    def setup(self, mode=None, level=None):
        """Summary
        """
        self.mode = mode or self.mode
        self.level = level or self.level
        # load default config
        with open(util.get_config('logging'), 'r') as file_:
            config = json.load(file_)
        # switch modes
        if self.mode == 'all':
            hndls = ["console", "info_file_handler", "error_file_handler"]
        elif self.mode == 'debug':
            hndls = ["console_debug"]
        elif self.mode == 'console':
            hndls = ["console"]
        elif self.mode == 'files':
            hndls = ["info_file_handler", "error_file_handler"]
        else:
            hndls = []
        # adapt handlers level
        for hndl in hndls:
            if config['handlers'][hndl]['level'] == 'NOTSET':
                config['handlers'][hndl]['level'] = self.level
        # add handlers to root
        config['root']['handlers'] = hndls
        # load configuration
        logging.config.dictConfig(config)

    @staticmethod
    def get_level(name):
        """get logging level through the name

        Args:
            name (str): logging level name

        Returns:
            int: logging level as int
        """
        return getattr(logging, name)

    @staticmethod
    def get_logger(name):
        """get a logger through it's name

        Args:
            name (str): logger name

        Returns:
            logging.Logger: logger instance
        """
        return logging.getLogger(name)

    @staticmethod
    def get_logger_files(name):
        """get all files used by a logger
        This can be used to delete the files before a specific run

        Args:
            name (str): logger name

        Returns:
            list: list of files used by the logger
        """
        logger = logging.getLogger(name)
        files = list()
        for hndl in logger.handlers:
            if hasattr(hndl, 'baseFilename'):
                files.append(hndl.baseFilename)
        return files

    @staticmethod
    def enable_logger(name, handlers=None):
        """enable a specific logger by name
        this can be used to modify the logging behavior if the default (root)
        logger's structure is not adequate

        Args:
            name (str): logger's name
            handlers (str/logging.Handler/list): handlers to be used (can be name(s)
                or on instance of logging.Handler)
        """
        if isinstance(handlers, str):
            handlers = [handlers]
        # load default config
        with open(util.get_config('logging'), 'r') as file_:
            config = json.load(file_)
        config.pop('root', None)
        # setup config
        loggers = {
            name: {
                "handlers": handlers,
                "propagate": False
            }
        }
        config['loggers'] = loggers
        logging.config.dictConfig(config)
        # fetch empty handlers
        if not handlers:
            logger = logging.getLogger(name)
            logger.handlers = []
            logger.addHandler(logging.NullHandler())

    @staticmethod
    def disable_logger(name):
        """disable a specific logger by name

        Args:
            name (str): logger's name
        """
        config = {
            "version": 1,
            "disable_existing_loggers": False,
            "loggers": {
                name: {
                    "handlers": [],
                    "propagate": True
                }
            }
        }
        logging.config.dictConfig(config)
        logger = logging.getLogger(name)
        logger.handlers = []
        logger.addHandler(logging.NullHandler())

    @staticmethod
    def get_formatter(name):
        """get a formatter by a pre-defined named
        The possible formatters names can be listed with ``get_formatters_names()``

        Args:
            name (str): formatter's name

        Returns:
            logging.Formatter: pre-defined formatter

        Raises:
            ValueError: error raised if the specified names is not defined
        """
        # load default config
        with open(util.get_config('logging'), 'r') as file_:
            config = json.load(file_)
        # get format
        if name in config['formatters']:
            formatter = config['formatters'][name]
        else:
            raise ValueError("formatter name should be on off %s" % config['formatters'].keys)
        # create formatter
        if 'formatTime' in formatter:
            formatter = logging.Formatter(fmt=formatter['format'], datefmt=formatter['formatTime'])
        else:
            formatter = logging.Formatter(fmt=formatter['format'])
        return formatter

    @staticmethod
    def get_formatters_names():
        """get list of all pre-defined formatter names

        Returns:
            list: available formatters
        """
        with open(util.get_config('logging'), 'r') as file_:
            config = json.load(file_)
        return config['formatters'].keys()

    @staticmethod
    def get_handlers_names():
        """get list of all pre-defined handlers names

        Returns:
            list: available handlers
        """
        with open(util.get_config('logging'), 'r') as file_:
            config = json.load(file_)
        return config['handlers'].keys()


###############################################################################
class StreamManager(object):

    """Summary

    Attributes:
        buffer (TYPE): Description
        handler (TYPE): Description
        log (TYPE): Description
        logger (TYPE): Description
        name (TYPE): Description
    """

    def __init__(self, name, logger=None):
        """Summary

        Args:
            name (TYPE): Description
            logger (None, optional): Description

        Deleted Parameters:
            logger (TYPE): Description
        """
        # setup
        self.log = logger or logging.getLogger(__name__ + '.' + self.__class__.__name__)
        self.name = name
        self.logger = logging.getLogger(name)
        self.handler = None
        self.buffer = None
        # search for handlers with StringBuffer
        srch = []
        for handler in self.logger.handlers:
            if (hasattr(handler, 'stream')) and (isinstance(handler.stream, StringBuffer)):
                srch.append(handler)
        if len(srch) > 1:
            self.log.critical('multiple handlers with an "StringBuffer" streamer , aborting.')
        elif len(srch) == 1:
            self.handler = srch[0]
            self.buffer = self.handler.stream
            self.buffer.add_manager(self)
            self.setup_logger()

    def __del__(self):
        """Summary

        Returns:
            TYPE: Description
        """
        # remove self from buffer
        self.buffer.del_manager(self)
        if self.buffer.is_used():
            return
        # remove handler from logger
        self.logger.removeHandler(self.handler)
        # enable propagate if logger has NullHandler
        handlers = self.logger.handlers
        if (len(handlers) == 1) and (isinstance(handlers[0], logging.NullHandler)):
            self.logger.propagate = True
        elif not handlers:
            self.logger.propagate = True
            self.logger.addHandler(logging.NullHandler)
        # flush and close StringBuffer
        self.close()
        return

    def add_buffer_handler(self, formatter, level):
        """Summary

        Args:
            formatter (TYPE): Description
            level (TYPE): Description
        """
        if self.handler:
            if self.handler.stream != self.buffer:
                self.log.critical('stream differs, aborting.')
            self.log.debug('handler already exists, overwritting level and formatter.')
            self.handler.setLevel(level)
            self.handler.setFormatter(formatter)
        else:
            self.buffer = StringBuffer()
            handler = logging.StreamHandler(self.buffer)
            handler.setLevel(level)
            handler.setFormatter(formatter)
            self.buffer.add_manager(self)
            self.handler = handler
        self.setup_logger()

    def setup_logger(self):
        """Summary
        """
        self.logger.propagate = False
        if self.handler not in self.logger.handlers:
            self.logger.addHandler(self.handler)

    def nprint(self):
        """Summary
        """
        print self.get()

    def get(self):
        """get the content of the string buffer

        Returns:
            str: content of the string buffer
        """
        self.handler.flush()
        self.buffer.flush()
        data = self.buffer.getvalue()
        self.buffer.truncate(0)
        return data

    def close(self):
        """close the string buffer

        Returns:
            str: content of the string buffer
        """
        data = self.get()
        self.buffer.close()
        return data


class StringBuffer(StringIO):

    """Summary

    Attributes:
        log (TYPE): Description
        managers (TYPE): Description
    """

    def __init__(self, *args, **kwargs):
        """Summary

        Args:
            *args: Description
            **kwargs: Description
        """
        if 'logger' in kwargs:
            self.log = kwargs['logger'] or logging.getLogger(__name__ + '.' +
                                                             self.__class__.__name__)
        self.managers = weakref.WeakValueDictionary()
        StringIO.__init__(self, *args, **kwargs)

    def add_manager(self, manager):
        """Summary

        Args:
            manager (TYPE): Description

        Raises:
            ValueError: Description
        """
        if not isinstance(manager, StreamManager):
            raise ValueError('manager should be of type "StreamManager"')
        id_ = id(manager)
        if id_ not in self.managers:
            self.managers[id_] = manager
        else:
            raise ValueError('the given "StreamManager" instance is already referenced to.')

    def del_manager(self, manager):
        """Summary

        Args:
            manager (TYPE): Description

        Raises:
            ValueError: Description
        """
        if not isinstance(manager, StreamManager):
            raise ValueError('manager should be of type "StreamManager"')
        id_ = id(manager)
        if id_ in self.managers:
            self.managers.pop(id_)

    def is_used(self):
        """Summary

        Returns:
            TYPE: Description
        """
        return len(self.managers.valuerefs()) > 0


###############################################################################
if __name__ == '__main__':
    sys.exit(0)
