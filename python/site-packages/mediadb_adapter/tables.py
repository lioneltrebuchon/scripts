#!/usr/bin/env python2
"""Tables module
"""

import sys
import logging
import json

from abc import ABCMeta, abstractmethod, abstractproperty

from .clients import MediaDatabase
from .util import MyEncoder

logging.basicConfig(format='[%(levelname)s] %(name)s.%(funcName)s(): %(message)s', level=logging.DEBUG)


###############################################################################
class Table(object):

    """Base for Tables handler

    Attributes:
        client (.client.MediaDatabase): client instance to use for querying
        data (dict): query result
        log (logging.Logger): logger instance for logging
    """

    __metaclass__ = ABCMeta

    def __init__(self, *args, **kwargs):
        """Initializer

        Args:
            *args: ignored
            **kwargs: used to aggregate client and logger

        Raises:
            ValueError: if client is wrong instance type
        """
        self.log = kwargs.get('logger') or logging.getLogger(__name__ + '.' + self.__class__.__name__)
        self.client = kwargs.get('client') or MediaDatabase()
        if not isinstance(self.client, MediaDatabase):
            raise ValueError('"client" argument should be of type "clients.MediaDatabase".')
        self.data = kwargs.get('data') or []
        self._columns = None

    def __str__(self):
        """Overload ``print()``

        Returns:
            str: representation to be printed
        """
        try:
            return json.dumps(self.data, indent=4, cls=MyEncoder, separators=(',', ': '))
        except:
            return str(self.data)

    def __eq__(self, other):
        """Overload ``==``

        Args:
            other (.Table): other instance of same type to be compared to

        Returns:
            boolean: comparison result
        """
        if isinstance(self, other.__class__):
            return self.data == other.data
        return False

    @abstractproperty
    def type(self):
        """abstract property to represent type of table
        """
        pass

    @property
    def columns(self):
        """property containing the names of all columns of current table type

        Returns:
            list: column names
        """
        if not self._columns:
            self._columns = self.getColumns()
        return self._columns.keys()

    def getColumns(self):
        """return the names of all columns of current table type

        Returns:
            dict: column names and id
        """
        cols = self.client.get('exec sp_columns %s' % self.type)
        res = dict()
        for col in cols:
            res[col['COLUMN_NAME']] = col
        return res

    def getColumnValues(self, name):
        """return all values used for a specifc column (unique)

        Args:
            name (str): column name (see self.columns)

        Returns:
            list: unique used values
        """
        if name not in self.columns:
            self.log.error('name "%s" not a column', name)
            return None
        res = self.client.get('SELECT DISTINCT %s.%s FROM %s' % (self.type, name, self.type))
        if res:
            res = [item[name] for item in res]
        return res

    def find(self, column, value, max_cnt=1):
        """search in database with a column=value pair

        Notes:
            if one result is found then the data is saved under self.data

        Args:
            column (str): column name
            value (str): value to search for
            max_cnt (int, optional): maximum number of results, disbale with None

        Returns:
            list: list of query results
        """
        query = 'SELECT * FROM %s WHERE %s=\'%s\'' % (self.type, column, value)
        res = self.client.get(query)
        if (max_cnt) and (len(res) > max_cnt):
            self.log.error('too many "%s" entities found with %s=%s', self.type, column, value)
        elif not res:
            self.log.error('no "%s" entities found with id %s=%s', self.type, column, value)
        else:
            self.data = res[0]
        return res

    def get(self, oid):
        """get data based on OID

        Notes:
            if one result is found then the data is saved under self.data

        Args:
            oid (str): OID value

        Returns:
            list: list of query results
        """
        res = self.find('OID', oid, 1)
        return res


###############################################################################
class Package(Table):

    """Handle ``Package`` table

    Attributes:
        extracts (list): list of Extracts referencing to this Package
        satellites (list): list of Satellites referencing to this Package
        tracks (list): list of Tracks referencing to this Package
    """

    def __init__(self, *args, **kwargs):
        """Initializer

        Args:
            *args: passed to base initializer
            **kwargs: load data during initialization
        """
        Table.__init__(self, *args, **kwargs)
        if 'id' in kwargs:
            self.fromId(kwargs['id'])
        if 'track' in kwargs:
            self.fromTrack(kwargs['track'])
        if 'extract' in kwargs:
            self.fromExtract(kwargs['extract'])
        self.tracks = []
        self.extracts = []
        self.satellites = []

    @property
    def type(self):
        """type property defining mapping to database table

        Returns:
            str: database table name
        """
        return 'Package'

    def fromId(self, id):
        """load Package's data based on a Extract instance

        Notes:
            data is not saved if multiple entires are found

        Args:
            id (int): table entry to search for reference

        Returns:
            list: list of :class:`.Package` instances
        """
        res = self.find('PackageID', id)
        return [Package(client=self.client, data=package) for package in res]

    def fromTrack(self, track):
        """load Package's data based on a Extract instance

        Notes:
            data is not saved if multiple entires are found

        Args:
            track (.Track): table entry to search for reference

        Returns:
            list: list of :class:`.Package` instances

        Raises:
            ValueError: if input do not correspond the the expected class
        """
        if not isinstance(track, Track):
            raise ValueError('"track" argument should be of type "tables.Track".')
        res = self.get(track.data['PackageOID'])
        return [Package(client=self.client, data=package) for package in res]

    def fromExtract(self, extract):
        """load Package's data based on a Extract instance

        Notes:
            data is not saved if multiple entires are found

        Args:
            extract (.Extract): table entry to search for reference

        Returns:
            list: list of :class:`.Package` instances

        Raises:
            ValueError: if input do not correspond the the expected class
        """
        if not isinstance(extract, Extract):
            raise ValueError('"extract" argument should be of type "tables.Extract".')
        res = self.get(extract.data['PackageOID'])
        return [Package(client=self.client, data=package) for package in res]

    def getTracks(self):
        """save and return Tracaks using the specific OID

        Returns:
            list: list of:class:`.Track` instances
        """
        query = '''
            SELECT T.*, TT.Name AS TrackTypeName FROM Package AS P
            INNER JOIN Track AS T ON P.OID=T.PackageOID
            INNER JOIN TrackType AS TT ON TT.OID=T.TrackTypeOID
            WHERE P.OID=\'%s\';
        '''
        self.tracks = [Track(client=self.client, data=track)
                       for track in self.client.get(query % self.data['OID'])]
        return self.tracks

    def getExtracts(self):
        """save and return Extract using the specific OID

        Returns:
            list: list of:class:`.Extract` instances
        """
        query = '''
            SELECT E.* FROM Package AS P
            INNER JOIN Extract AS E ON P.OID=E.PackageOID
            WHERE P.OID=\'%s\';
        '''
        self.extracts = [Extract(client=self.client, data=extract)
                         for extract in self.client.get(query % self.data['OID'])]
        return self.extracts

    def getSatellites(self):
        """save and return Satellite using the specific OID

        Returns:
            list: list of:class:`.Satellite` instances
        """
        query = '''
            SELECT SI.* FROM Package AS P
            INNER JOIN SatelliteIdentifier AS SI ON P.OID=SI.PackageOID
            WHERE P.OID=\'%s\';
        '''
        self.satellites = [Satellite(client=self.client, data=satellite)
                           for satellite in self.client.get(query % self.data['OID'])]
        return self.satellites


class Track(Table):

    """Handle ``Track`` table

    Attributes:
        packages (list): list of Packages referencing to this Track
        track_types (list): list of TrackTypes referencing to this Track
    """

    def __init__(self, *args, **kwargs):
        """Initializer

        Args:
            *args: passed to base initializer
            **kwargs: load data during initialization
        """
        Table.__init__(self, *args, **kwargs)
        if 'track_type' in kwargs:
            self.fromTrackType(kwargs['track_type'])
        if 'package' in kwargs:
            self.fromPackage(kwargs['package'])
        self.track_types = []
        self.packages = []

    @property
    def type(self):
        """type property defining mapping to database table

        Returns:
            str: database table name
        """
        return 'Track'

    def fromTrackType(self, track_type):
        """load Track's data based on a TrackType instance

        Notes:
            data is not saved if multiple entires are found

        Args:
            track_type (.TrackType): table entry to search for reference

        Returns:
            list: list of :class:`.Track` instances

        Raises:
            ValueError: if input do not correspond the the expected class
        """
        if not isinstance(track_type, TrackType):
            raise ValueError('"track_type" argument should be of type "tables.TrackType".')
        res = self.find('TrackTypeOID', track_type.data['OID'])
        return [Track(client=self.client, data=track) for track in res]

    def fromPackage(self, package):
        """load Track's data based on a TrackType instance

        Notes:
            data is not saved if multiple entires are found

        Args:
            package (.Package): table entry to search for reference

        Returns:
            list: list of :class:`.Track` instances

        Raises:
            ValueError: if input do not correspond the the expected class
        """
        if not isinstance(package, Package):
            raise ValueError('"package" argument should be of type "tables.Package".')
        res = self.find('PackageOID', package['OID'])
        return [Track(client=self.client, data=track) for track in res]

    def getTypes(self):
        """save and return TrackTypes using the specific OID

        Returns:
            list: list of:class:`.TrackType` instances
        """
        query = '''
            SELECT TT.* FROM Track AS T
            INNER JOIN TrackType AS TT ON TT.OID=T.TrackTypeOID
            WHERE T.OID=\'%s\';
        '''
        self.track_types = [TrackType(client=self.client, data=track_type)
                            for track_type in self.client.get(query % self.data['OID'])]
        return self.track_types

    def getPackages(self):
        """save and return Packages using the specific OID

        Returns:
            list: list of:class:`.Package` instances
        """
        query = '''
            SELECT TT.* FROM Track AS T
            INNER JOIN Package AS P ON P.OID=T.PackageOID
            WHERE T.OID=\'%s\';
        '''
        self.packages = [TrackType(client=self.client, data=track_type)
                         for track_type in self.client.get(query % self.data['OID'])]
        return self.packages


class TrackType(Table):

    """Handle ``TrackType`` table

    Attributes:
        tracks (list): list of tracks referencing to this TrackType
    """

    def __init__(self, *args, **kwargs):
        """Initializer

        Args:
            *args: passed to base initializer
            **kwargs: load data during initialization
        """
        Table.__init__(self, *args, **kwargs)
        if 'track' in kwargs:
            self.fromTrack(kwargs['track'])
        self.tracks = []

    @property
    def type(self):
        """type property defining mapping to database table

        Returns:
            str: database table name
        """
        return 'TrackType'

    def fromTrack(self, track):
        """load TrackType's data based on a Track instance

        Notes:
            data is not saved if multiple entires are found

        Args:
            track (.Track): table entry to search for reference

        Returns:
            list: list of :class:`.TrackType` instances

        Raises:
            ValueError: if input do not correspond the the expected class
        """
        if not isinstance(track, Track):
            raise ValueError('"track" argument should be of type "tables.Track".')
        res = self.get(track.data['TrackTypeOID'])
        return [TrackType(client=self.client, data=track_type) for track_type in res]

    def getTracks(self):
        """save and return tracks using the specific OID

        Returns:
            list: list of:class:`.Track` instances
        """
        query = '''
            SELECT T.*, TT.Name AS TrackTypeName FROM TrackType AS TT
            INNER JOIN Track AS T ON TT.OID=T.TrackTypeOID
            WHERE TT.OID=\'%s\';
        '''
        self.tracks = [Track(client=self.client, data=track)
                       for track in self.client.get(query % self.data['OID'])]
        return self.tracks


class Satellite(Table):

    """Handle ``SatelliteIdentifier`` table
    """

    @property
    def type(self):
        """type property defining mapping to database table

        Returns:
            str: database table name
        """
        return 'SatelliteIdentifier'


###############################################################################
class Extract(Table):

    """Handle ``Extract`` table
    """

    @property
    def type(self):
        """type property defining mapping to database table

        Returns:
            str: database table name
        """
        return 'Extract'


class Source(Table):

    """Handle ``Source`` table
    """

    @property
    def type(self):
        """type property defining mapping to database table

        Returns:
            str: database table name
        """
        return 'Source'


class Property(Table):

    """Handle ``Property`` table
    """

    @property
    def type(self):
        """type property defining mapping to database table

        Returns:
            str: database table name
        """
        return 'Property'


class PropertyValue(Table):

    """Handle ``PropertyValue`` table
    """

    @property
    def type(self):
        """type property defining mapping to database table

        Returns:
            str: database table name
        """
        return 'PropertyValue'


class Playlist(Table):

    """Handle ``Playlist`` table
    """

    @property
    def type(self):
        """type property defining mapping to database table

        Returns:
            str: database table name
        """
        return 'Playlist'


class PlaylistExtract(Table):

    """Handle ``PlaylistExtract`` table
    """

    @property
    def type(self):
        """type property defining mapping to database table

        Returns:
            str: database table name
        """
        return 'PlaylistExtract'


###############################################################################
class User(Table):

    """Handle ``PhonakUser`` table
    """

    @property
    def type(self):
        """type property defining mapping to database table

        Returns:
            str: database table name
        """
        return 'PhonakUser'


class UserGroup(Table):

    """Handle ``PhonakUserGroup`` table
    """

    @property
    def type(self):
        """type property defining mapping to database table

        Returns:
            str: database table name
        """
        return 'PhonakUserGroup'


###############################################################################
class Version(Table):

    """Handle ``Version`` table
    """

    @property
    def type(self):
        """type property defining mapping to database table

        Returns:
            str: database table name
        """
        return 'Version'


class Settings(Table):

    """Handle ``Settings`` table
    """

    @property
    def type(self):
        """type property defining mapping to database table

        Returns:
            str: database table name
        """
        return 'Settings'


class Dtproperties(Table):

    """Handle ``dtproperties`` table
    """

    @property
    def type(self):
        """type property defining mapping to database table

        Returns:
            str: database table name
        """
        return 'dtproperties'


###############################################################################
if __name__ == '__main__':
    sys.exit(0)
